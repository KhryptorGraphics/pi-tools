// Code generated by sqlc. DO NOT EDIT.
// source: trips.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const beginTrip = `-- name: BeginTrip :one
INSERT INTO trips (id, left_at)
VALUES ($1, $2)
RETURNING id, left_at, returned_at, ignored_at
`

type BeginTripParams struct {
	ID     uuid.UUID
	LeftAt time.Time
}

func (q *Queries) BeginTrip(ctx context.Context, arg BeginTripParams) (Trip, error) {
	row := q.db.QueryRowContext(ctx, beginTrip, arg.ID, arg.LeftAt)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.LeftAt,
		&i.ReturnedAt,
		&i.IgnoredAt,
	)
	return i, err
}

const endTrip = `-- name: EndTrip :exec
UPDATE trips
SET returned_at = $2
WHERE id = $1
AND returned_at IS NULL
`

type EndTripParams struct {
	ID         uuid.UUID
	ReturnedAt sql.NullTime
}

func (q *Queries) EndTrip(ctx context.Context, arg EndTripParams) error {
	_, err := q.db.ExecContext(ctx, endTrip, arg.ID, arg.ReturnedAt)
	return err
}

const getCurrentTrip = `-- name: GetCurrentTrip :one
SELECT id, left_at, returned_at, ignored_at
FROM trips
WHERE ignored_at IS NULL
  AND returned_at IS NULL
ORDER BY left_at DESC
LIMIT 1
`

func (q *Queries) GetCurrentTrip(ctx context.Context) (Trip, error) {
	row := q.db.QueryRowContext(ctx, getCurrentTrip)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.LeftAt,
		&i.ReturnedAt,
		&i.IgnoredAt,
	)
	return i, err
}

const getLastCompletedTrip = `-- name: GetLastCompletedTrip :one
SELECT id, left_at, returned_at, ignored_at
FROM trips
WHERE ignored_at IS NULL
AND returned_at IS NOT NULL
ORDER BY left_at DESC
LIMIT 1
`

func (q *Queries) GetLastCompletedTrip(ctx context.Context) (Trip, error) {
	row := q.db.QueryRowContext(ctx, getLastCompletedTrip)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.LeftAt,
		&i.ReturnedAt,
		&i.IgnoredAt,
	)
	return i, err
}

const getTrip = `-- name: GetTrip :one
SELECT id, left_at, returned_at, array_remove(array_agg(DISTINCT tag ORDER BY tag), NULL)::text[] as tags
FROM trips
         LEFT JOIN trip_taggings tt ON trips.id = tt.trip_id
WHERE id = $1
GROUP BY id
LIMIT 30
`

type GetTripRow struct {
	ID         uuid.UUID
	LeftAt     time.Time
	ReturnedAt sql.NullTime
	Tags       []string
}

func (q *Queries) GetTrip(ctx context.Context, id uuid.UUID) (GetTripRow, error) {
	row := q.db.QueryRowContext(ctx, getTrip, id)
	var i GetTripRow
	err := row.Scan(
		&i.ID,
		&i.LeftAt,
		&i.ReturnedAt,
		pq.Array(&i.Tags),
	)
	return i, err
}

const ignoreTrip = `-- name: IgnoreTrip :execrows
UPDATE trips
SET ignored_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) IgnoreTrip(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, ignoreTrip, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const listTrips = `-- name: ListTrips :many
SELECT id, left_at, returned_at, array_remove(array_agg(DISTINCT tag ORDER BY tag), NULL)::text[] as tags
FROM trips
         LEFT JOIN trip_taggings tt ON trips.id = tt.trip_id
WHERE ignored_at IS NULL
GROUP BY id, left_at
ORDER BY left_at DESC
LIMIT 30
`

type ListTripsRow struct {
	ID         uuid.UUID
	LeftAt     time.Time
	ReturnedAt sql.NullTime
	Tags       []string
}

func (q *Queries) ListTrips(ctx context.Context) ([]ListTripsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTrips)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTripsRow
	for rows.Next() {
		var i ListTripsRow
		if err := rows.Scan(
			&i.ID,
			&i.LeftAt,
			&i.ReturnedAt,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
