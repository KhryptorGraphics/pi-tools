package rpc

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"net"
	"net/http"

	"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

var (
	httpPort *int
	grpcPort *int
)

// SetDefaultHTTPPort configures the current process to run an HTTP server, by default listening on the given port.
// This should be called before calling flag.Parse(), since it creates the -http-port flag for overriding the port.
func SetDefaultHTTPPort(port int) {
	httpPort = flag.Int("http-port", port, "HTTP port to listen on for metrics and API requests")
}

// SetDefaultGRPCPort configures the current process to run a gRPC server, by default listening on the given port.
// This should be called before calling flag.Parse(), since it creates the -grpc-port flag for overriding the port.
// Running a gRPC server is only necessary to receive requests from non-JavaScript clients. JavaScript clients use
// grpc-web which is served over the plain HTTP port.
func SetDefaultGRPCPort(port int) {
	grpcPort = flag.Int("grpc-port", port, "gRPC port to listen on for non-grpc-web API requests")
}

// ListenAndServe starts listening in the background for HTTP and optionally gRPC requests.
//
// You can configure handlers for HTTP requests by adding handlers to the default HTTP serve mux using http.Handle.
// The HTTP server will be configured for tracing requests. The HTTP server will check for requests that are grpc-web
// requests and will handle them with gRPC using any registered gRPC services.
//
// If SetDefaultGRPCPort was called, then this will also start a gRPC server with any registered services.
//
// The servers listen indefinitely, only stopping when the process exits. Graceful shutdown may be added in the future.
func ListenAndServe(opts ...Option) {
	if httpPort == nil {
		log.Panicf("no default HTTP port configured")
	}

	h, g := newHandler(opts...)
	addr := fmt.Sprintf(":%d", *httpPort)

	go func() {
		log.Printf("Listening on %s for HTTP", addr)
		if err := http.ListenAndServe(addr, h); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				log.Panicf("error listening to HTTP: %v", err)
			}
		}
	}()

	if grpcPort != nil {
		go func() {
			grpcAddr := fmt.Sprintf(":%d", *grpcPort)
			lis, err := net.Listen("tcp", grpcAddr)
			if err != nil {
				log.Panicf("error listening to gRPC: %v", err)
			}

			log.Printf("Listening on %s for gRPC", grpcAddr)
			if err := g.Serve(lis); err != nil {
				log.Panicf("error serving gRPC: %v", err)
			}
		}()
	}
}

func newHandler(opts ...Option) (http.Handler, *grpc.Server) {
	cfg := &config{}
	for _, opt := range opts {
		opt(cfg)
	}

	grpcServer := grpc.NewServer(
		grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()))
	reflection.Register(grpcServer)

	if cfg.registerFn != nil {
		cfg.registerFn(grpcServer)
	}

	handler := otelhttp.NewHandler(
		http.DefaultServeMux,
		"Server",
		otelhttp.WithMessageEvents(otelhttp.ReadEvents, otelhttp.WriteEvents),
		otelhttp.WithFilter(func(r *http.Request) bool {
			return r.URL.Path != "/metrics"
		}))

	return handler, grpcServer
}

// Option is an option to configure the server that is started with ListenAndServe.
type Option func(*config)

type config struct {
	registerFn func(*grpc.Server)
}

// WithRegisteredServices configures a function that will be called with the gRPC server that ListenAndServe creates.
// This allows registering any gRPC services that the process wants to provide using the Register*Server methods
// generated by the protobuf compiler.
func WithRegisteredServices(f func(server *grpc.Server)) Option {
	return func(c *config) {
		c.registerFn = f
	}
}
